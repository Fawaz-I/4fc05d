{"ast":null,"code":"/**\n * Find all upstream forms (direct and transitive dependencies) for a given form node\n */\nexport const findUpstreamForms = (graph, formId) => {\n  const nodes = graph.nodes;\n  const edges = graph.edges;\n  const forms = graph.forms;\n\n  // Map to store form nodes by ID\n  const formNodesMap = nodes.filter(node => node.type === 'form').reduce((map, node) => {\n    map[node.id] = node;\n    return map;\n  }, {});\n\n  // Map to store form details by ID\n  const formsMap = forms.reduce((map, form) => {\n    map[form.id] = form;\n    return map;\n  }, {});\n\n  // Find direct upstream forms (immediate dependencies)\n  const directUpstreamNodeIds = edges.filter(edge => edge.target === formId).map(edge => edge.source).filter(sourceId => {\n    var _formNodesMap$sourceI;\n    return ((_formNodesMap$sourceI = formNodesMap[sourceId]) === null || _formNodesMap$sourceI === void 0 ? void 0 : _formNodesMap$sourceI.type) === 'form';\n  });\n  const directUpstreamForms = directUpstreamNodeIds.map(nodeId => formsMap[nodeId]).filter(Boolean);\n\n  // Find transitive upstream forms (ancestors/indirect dependencies)\n  const visitedNodeIds = new Set([...directUpstreamNodeIds, formId]);\n  const transitiveUpstreamForms = [];\n  const findTransitiveDependencies = nodeIds => {\n    const nextLevelNodeIds = [];\n    nodeIds.forEach(nodeId => {\n      const upstreamIds = edges.filter(edge => edge.target === nodeId).map(edge => edge.source).filter(sourceId => {\n        var _formNodesMap$sourceI2;\n        return ((_formNodesMap$sourceI2 = formNodesMap[sourceId]) === null || _formNodesMap$sourceI2 === void 0 ? void 0 : _formNodesMap$sourceI2.type) === 'form' && !visitedNodeIds.has(sourceId);\n      });\n      upstreamIds.forEach(id => {\n        visitedNodeIds.add(id);\n        nextLevelNodeIds.push(id);\n        const form = formsMap[id];\n        if (form) {\n          transitiveUpstreamForms.push(form);\n        }\n      });\n    });\n    if (nextLevelNodeIds.length > 0) {\n      findTransitiveDependencies(nextLevelNodeIds);\n    }\n  };\n  findTransitiveDependencies(directUpstreamNodeIds);\n  return {\n    direct: directUpstreamForms,\n    transitive: transitiveUpstreamForms\n  };\n};\n\n/**\n * Extract field definitions from a form\n */\nexport const extractFormFields = form => {\n  const fieldSchema = form.field_schema;\n  if (!fieldSchema || !fieldSchema.properties) {\n    return [];\n  }\n  return Object.entries(fieldSchema.properties).map(([fieldKey, fieldProps]) => ({\n    id: fieldKey,\n    name: fieldProps.title || fieldKey\n  }));\n};\n\n/**\n * Get form by ID from the graph\n */\nexport const getFormById = (graph, formId) => {\n  return graph.forms.find(form => form.id === formId);\n};","map":{"version":3,"names":["findUpstreamForms","graph","formId","nodes","edges","forms","formNodesMap","filter","node","type","reduce","map","id","formsMap","form","directUpstreamNodeIds","edge","target","source","sourceId","_formNodesMap$sourceI","directUpstreamForms","nodeId","Boolean","visitedNodeIds","Set","transitiveUpstreamForms","findTransitiveDependencies","nodeIds","nextLevelNodeIds","forEach","upstreamIds","_formNodesMap$sourceI2","has","add","push","length","direct","transitive","extractFormFields","fieldSchema","field_schema","properties","Object","entries","fieldKey","fieldProps","name","title","getFormById","find"],"sources":["/Users/fawaz/dev/4fc05d/src/services/graphService.ts"],"sourcesContent":["import { BlueprintGraphResponse, Node, Form, FormFieldDisplay } from '../types';\n/**\n * Find all upstream forms (direct and transitive dependencies) for a given form node\n */\nexport const findUpstreamForms = (\n  graph: BlueprintGraphResponse,\n  formId: string\n): { direct: Form[]; transitive: Form[] } => {\n  const nodes = graph.nodes;\n  const edges = graph.edges;\n  const forms = graph.forms;\n\n  // Map to store form nodes by ID\n  const formNodesMap = nodes\n    .filter((node) => node.type === 'form')\n    .reduce((map, node) => {\n      map[node.id] = node;\n      return map;\n    }, {} as Record<string, Node>);\n\n  // Map to store form details by ID\n  const formsMap = forms.reduce((map, form) => {\n    map[form.id] = form;\n    return map;\n  }, {} as Record<string, Form>);\n\n  // Find direct upstream forms (immediate dependencies)\n  const directUpstreamNodeIds = edges\n    .filter((edge) => edge.target === formId)\n    .map((edge) => edge.source)\n    .filter((sourceId) => formNodesMap[sourceId]?.type === 'form');\n\n  const directUpstreamForms = directUpstreamNodeIds\n    .map((nodeId) => formsMap[nodeId])\n    .filter(Boolean);\n\n  // Find transitive upstream forms (ancestors/indirect dependencies)\n  const visitedNodeIds = new Set([...directUpstreamNodeIds, formId]);\n  const transitiveUpstreamForms: Form[] = [];\n\n  const findTransitiveDependencies = (nodeIds: string[]) => {\n    const nextLevelNodeIds: string[] = [];\n\n    nodeIds.forEach((nodeId) => {\n      const upstreamIds = edges\n        .filter((edge) => edge.target === nodeId)\n        .map((edge) => edge.source)\n        .filter(\n          (sourceId) =>\n            formNodesMap[sourceId]?.type === 'form' &&\n            !visitedNodeIds.has(sourceId)\n        );\n\n      upstreamIds.forEach((id) => {\n        visitedNodeIds.add(id);\n        nextLevelNodeIds.push(id);\n\n        const form = formsMap[id];\n        if (form) {\n          transitiveUpstreamForms.push(form);\n        }\n      });\n    });\n\n    if (nextLevelNodeIds.length > 0) {\n      findTransitiveDependencies(nextLevelNodeIds);\n    }\n  };\n\n  findTransitiveDependencies(directUpstreamNodeIds);\n\n  return {\n    direct: directUpstreamForms,\n    transitive: transitiveUpstreamForms,\n  };\n};\n\n/**\n * Extract field definitions from a form\n */\nexport const extractFormFields = (form: Form): FormFieldDisplay[] => {\n  const fieldSchema = form.field_schema;\n\n  if (!fieldSchema || !fieldSchema.properties) {\n    return [];\n  }\n\n  return Object.entries(fieldSchema.properties).map(\n    ([fieldKey, fieldProps]) => ({\n      id: fieldKey,\n      name: fieldProps.title || fieldKey,\n    })\n  );\n};\n\n/**\n * Get form by ID from the graph\n */\nexport const getFormById = (\n  graph: BlueprintGraphResponse,\n  formId: string\n): Form | undefined => {\n  return graph.forms.find((form) => form.id === formId);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}